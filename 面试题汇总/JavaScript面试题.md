## 1.1 解答题

1. JavaScript 的数据类型

> - 基本数据类型：number、string、Boolean、undefined、null
> - 引用类型：Object

2. javascript 的 typeof 返回哪些数据类型

> - Object、number、Function、boolean、underfind 

3. 数组方法 pop() push() unshift() shift()

> - push() 尾部添加 	pop() 尾部删除
> - unshift() 头部添加     shift() 头部删除

4. 写一个获取非行间样式的函数

```js
function getStyle(obj, attr) {
  return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj)[attr];
}
```

5. 事件委托是什么

- 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。

- 这里其实还有2层意思的：

  - 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；

  - 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。

- 事件委托是`利用事件的冒泡原理`来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，`委托它们父级代为执行事件`。

- `总结：` 事件委托是利用事件的冒泡原理，委托他们的父级代为执行事件。

6. 闭包是什么，有什么特性，对页面有什么影响

> - 函数能够持久保存自己`定义时的所处环境`，并且即使自己在其他的环境被调用的时候，依然可以访问自己定义时所处环境的值，一个函数可以把它自己`内部的语句`，和自己`声明时所处的作用域`一起封装成了一个`密闭环境`，我们称为`“闭包”`（Closures）。

7.  添加 删除 替换 插入到某个接点的方法

> - obj.appendChidl()
> - obj.innersetBefore
> - obj.replaceChild
> - obj.removeChild 



8.  HTTP协议的状态消息都有哪些 ?(如 200、302 对应的描述 ) 

> Web 服务器用来告诉客户端，发生了什么事，也就是一种快速解决问题的方式。
>
> 1XX 信息性状态码。
>
> 2XX 成功状态码。
>
> 3XX 重定向状态码。
>
> 4XX 客户端错误状态码。
>
> 5XX 服务器错误状态码

9.  AJAX是什么 ?  AJAX跨域的解决办法 ? 

> 1. ajax 是一种用于创建快速动态网页的技术。是一种浏览器和服务器交互技术，基本思想是允许一个浏览器向一个远程页面 /服务做异步的 http调用，并且用收到的数据来更新一个当前 web 页面而不必刷新整个页面。该技术能够改进客户端的体验。
>
> 2. 跨域问题：跨域问题简单的理解就是因为 JS 同源策略的限制（安全性限制）， a.com 域名下的 JS 无
>
>    法操作 b.com 或 c.a.com 下的对象。 Ajax 可以采用 jsonp 来实现跨域。
>
>    JSONP 的最基本的原理是：动态添加一个 <script> 标签，而 script 标签的 src 属性是没有跨域的限制的。这样说来，这种跨域方式其实与 ajax XmlHttpRequest 协议无关了。当 GET 请求从被调用页面返回时，可以返回一段 JavaScript 代码，这段代码会自动调用主页面中的一个 callback 函数。
>
>    Jsonp 优点：不受同源策略的影响，它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest 或 ActiveX 的支持； 并且在请求完毕后可以通过调用 callback 的方式回传结果。
>
>    Jsonp 缺点：它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求；它只支持跨域 HTTP 请求这
>
>    种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。

10. JavaScript继承有哪两种形式形式，进行描述

> 1. 构造函数借用：在子类构造方法内，通过 apply/call 将 this 作为参数传入。优点：可以向父类构造方法传递参数，即给 apply 第二个参数： arguments ；父类中的属性都被复制到子类实例中， 属性之间无干扰， 无论是引用类型还是封装类型。缺点：每一个实例对象都拥有一份父类方法的拷贝，互不干扰，所以无法统一修改；无法拥有父类原型中定义的方法；子类的实例对象不能通过 instanceof 操作符判断是否是父类的实例。
>
> 2. 原型链：指定子类的 prototype 为父类的一个实例对象。优缺点和构造函数借用刚好相反。 这里特别说明下属性之间相互干扰 （对应构造函数借用的优点 2）。
>
> 3. 组合式继承： 上面两种方式互补一下， 即用构造方法借用来继承父类属性， 用原型链来继承父类方法。优点：封装保护了内部数据的完整性；封装使对象的重构更轻松；弱化模块间的耦合，提高对象的可重用性；有助于避免命名空间冲突。缺点：私用方法很难测试；必须与复杂的作用域链打交道，使错误调度更困难；容易形成过度封装；JavaScript 并不原生支持封装，所以在 JavaScript 中实现封装存在复杂性的问题



## 1.2 编程题



### 1.2.1 数组去重的方法

- 数组去重的方法有很多种，但是以下两种的效率是最高的

##### 1. 使用 Es6 的 Set 方法

```js
var arr = [1, 1, 2, 9, 6, 9, 6, 3, 1, 4, 5];
function newArr(arr) {
  return Array.from(new Set(arr))
}
console.log(newArr(arr))
```

- `Array.from()`方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。

```js
let arrayLike = {
    0: 'tom', 
    1: '65',
    2: '男',
    'length': 4
}
let arr = Array.from(arrayLike)
console.log(arr) // ['tom','65','男']
```

- 要将一个类数组对象转换为一个真正的数组，必须具备以下条件：

> - 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。
>
> - 该类数组对象的属性名必须为数值型或字符串型的数字
> - ps: 该类数组对象的属性名可以加引号，也可以不加引号

- ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。`new Set()` 返回 Set 对象，因此，可以使用 `Array.from` 转换为真正的数组。

- `Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：

```js
let arr = [12,45,97,9797,564,134,45642]
let set = new Set(arr)
console.log(Array.from(set, item => item + 1)) // [ 13, 46, 98, 9798, 565, 135, 45643 ]
```

- 将字符串转换为数组：

```js
let  str = 'hello world!';
console.log(Array.from(str)) // ["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", "!"]
```



##### 2. Es6 的Map() 方法

- 利用 `new Map` 方法的 get 函数和 set 函数，set 将数组的值作为键，1为值。然后用 get 获取键值，如果已经 set 那么键值为1，就不过push到aa里面。

```js
var arr = [1, 1, 2, 9, 6, 9, 6, 3, 1, 4, 5];
function newArr(arr) {
  let aa = [];
  let temp = new Map();
  for (let i = 0; i < arr.length; i++) {
    if (!temp.get(arr[i])) {
      temp.set(arr[i], 1);
      aa.push(arr[i]);
    }
  }
  return aa;
}
console.log(newArr(arr))
```

- Set类似于数组，而Map就类似于键值对（Key, Value）；ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。













