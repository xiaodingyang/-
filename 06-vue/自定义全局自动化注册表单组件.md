1. main.js中添加以下代码，使在 `./components/baseComponents`文件目录下的符合`/Base[A-Z]\w+\.(vue|js)$/`正则命名的vue文件都将被全局自动化注册。

```js
import upperFirst from "lodash/upperFirst"; //应用模块
import camelCase from "lodash/camelCase"; //转为驼峰命名

// 全局导入组件
const requireComponent = require.context(
  "./components/baseComponents", // 其组件目录的相对路径
  false, // 是否查询其子目录
  /Base[A-Z]\w+\.(vue|js)$/ // 匹配基础组件文件名的正则表达式，这里可以匹配的文件名为BaseXxxx.vue格式
);
requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName);

  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 剥去文件名开头的 `'./` 和结尾的扩展名
      fileName
        .split("/")
        .pop()
        .replace(/\.\w+$/, "")
    )
  );

  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  );
});

new Vue({
  el: "#app",
  router,
  components: { App },
  template: "<App/>"
});
```

2. baseComponents下面的BaseText文件

```html
<template>
  <div>
    <label>
      {{ label }}
      <input v-bind="$attrs" v-on="inputListeners" />
    </label>
  </div>
</template>

<script>
export default {
  inheritAttrs: false,
  props: ['label'],
  computed: {
    inputListeners() {
      var vm = this;
      //  将所有的对象合并为一个新对象
      return {
        ...this.$listeners, // 我们从父级添加所有的监听器 然后我们添加自定义监听器， 或覆写一些监听器的行为
        // 这里确保组件配合 `v-model` 的工作
        input(event) {
          vm.$emit('input', event.target.value);
        }
      };
    }
  }
};
</script>
```

3. 使用全局自动化注册组件，以下change可以顺利监听到BaseText里面的input，且v-model也能正常生效

```html
<template>
  <div>
    <BaseText @input="change" v-model="value" label="测试"></BaseText>
    <div>{{value}}</div>
  </div>
</template>
<script>
export default {
  data() {
    return {
      value: '测试值'
    };
  },
  methods: {
    change(value) {
      console.log('value', value);
    }
  }
};
</script>
```

